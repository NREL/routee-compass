parallelism = 2
response_persistence_policy = "persist_response_in_memory"
[response_output_policy]
type = "none"

# # example file output policy
# response_persistence_policy = "discard_response_from_memory"
# [response_output_policy]
# type = "file"
# filename = "output.json"
# format = { type = "json", newline_delimited = true }

[graph]
verbose = true

[mapping]
type = "vertex"
# # only if we want to read points from the edges for mapping.
# # if geometry_input_file is not provided, the graph vertices
# # are used for mapping.
# geometry_input_file = "edges-geometries-enumerated.txt.gz"

# # optional query distance tolerance for map matching,
# # an array of [Distance, DistanceUnit].
# tolerance = [15.0, "meters"]

# allow user to submit queries without destinations, such as when
# shortest path trees are the desired result, not routes.
queries_without_destinations = false

# only accept queries with map coordinates
# to allow debugging or avoid map matching, choose "edge" or "vertex" here
# also, an array such as ["point", "edge", "vertex"] is allowed
map_input_type = "point"

[algorithm]
type = "a*"

[traversal]
type = "distance"
distance_unit = "kilometers"

[access]
type = "no_access_model"

[cost]
cost_aggregation = "sum"
network_rates = {}

[frontier]
type = "no_restriction"

[termination]
type = "query_runtime"
limit = "00:10:00"
frequency = 100_000

[plugin]
input_plugins = []
output_plugins = []
