# # example file output policy
# response_persistence_policy = "discard_response_from_memory"
# [response_output_policy]
# type = "file"
# filename = "output.json"
# format = { type = "json", newline_delimited = true }

# [graph]
# verbose = true

# [mapping]
# # this matches incoming points to the nearest vertex in the graph.
# spatial_index_type = "vertex"
# # alternatively, builds the spatial index over edges in the graph.
# spatial_index_type = "edge"

# # if you don't have a file with linestring geometries, you can build
# # simple linestrings from the vertices of each edge list.
# geometry = { type = "from_vertices" } 
# geometry.type = "from_vertices"  # TOML shorthand for above

# # if you can bring your own, the resulting routes will have greater realism.
# geometry = { type = "from_linestrings", input_file = "edges-geometries-enumerated.txt.gz" }

# # optional query distance tolerance for map matching.
# tolerance.distance = 15.0
# tolerance.unit = "meters"

# # allow user to submit queries without destinations, such as when
# # shortest path trees are the desired result, not routes. true by default.
# queries_without_destinations = true

# # the default map input type is a combined strategy that attempts to
# # match by Point, otherwise expects the user to pass either a vertex ({origin|destination}_vertex)
# # or an edge ({origin|destination}_edge). a more restrictive strategy can be
# # specified here with a subset of these values or a single value such as "point".
# matching_type = ["point", "edge_id", "vertex_id"]

[system]
parallelism = 2
default_edge_list = 0
response_persistence_policy = "persist_response_in_memory"
response_output_policy.type = "none"

[mapping]
tolerance.distance = 30.0
tolerance.unit = "meters"
queries_without_destinations = false
matching_type = ["vertex_id"]
spatial_index_type = "vertex"
geometry.type = "from_vertices"

[algorithm]
type = "a*"

[search]
traversal = { type = "distance", distance_unit = "kilometers" }
constraint.type = "no_restriction"

[cost]
cost_aggregation = "sum"
network_rates = {}

[label]
type = "vertex"

[termination]
type = "query_runtime"
limit = "00:01:00"
frequency = 100_000

[plugin]
input_plugins = []
output_plugins = []
